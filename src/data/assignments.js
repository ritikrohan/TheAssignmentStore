export const assignments = [
    {
      "id": 1,
      "title": "DSC 395T Data Structures and Algorithms — Spring 2025 Wikiracer Solved",
      "description": "In this assignment, you will implement different types of graph searches that will run on Wikipedia. Speciﬁcally, Wikipedia pages are the graph nodes and links to other pages are the edges.\n\n1 Wikipedia, Wikiracer, and Graph Algorithms\nWikipedia is a giant online encyclopedia that anyone can edit (with approval), available at wikipedia.org. Among many other interesting properties, its size makes it particularly hard to digest. As such, a wiki racing game has been created that uses Wikipedia’s large graph as the basis for games. The goal is get from one speciﬁed Wikipedia page (the start node) to another (the goal node) as fast as possible (or perhaps in as few clicks as possible). You can ﬁnd variations of this game online by searching “Wikiracer.” We recommend that you play the game a couple of times ﬁrst before beginning this assignment. Here is one implementation that we recommend playing: https: //dlab.epfl.ch/wikispeedia/play/.\n\nBefore beginning this assignment, you should be familiar with the different types of graph searches that we dis-\ncussed in lecture, speciﬁcally, breadth-ﬁrst search (bfs), depth-ﬁrst search (dfs), and Dijkstra’s algorithm.\n\n2 Your Assignment\n2.1 Parser\nThis assignment has a few parts. First, we ask you to build a Wikipedia page parser. In other words, once we’ve downloaded the HTML markup for a Wikipedia page, we need to read the HTML code and ﬁnd all of the page’s neighbors (links to other Wikipedia pages). We provide the code to download a page’s HTML code, but we ask you to parse it inside the get_links_in_page function inside of py_wikiracer/wikiracer.py.\n\nHTML code is organized into different cascading tags, and it is the building block of all websites. For instance,\nconsider the following HTML markup:\n<html>\n<head>\n<script href=”…”></script>\n</head>\n<body>\n<p>This is a paragraph!</p>\n<p>I can put any text I want, including <a href=”/wiki/Science”>a link</a>.</p>\n</body>\n</html>\n\nWhen Google Chrome or Firefox encounter this HTML segment, they will interpret the HTML commands and cre-\nate a webpage with two paragraphs. The second one will have a link over the text “a link” that points to “/wiki/Science”. The ﬁrst thing to know about HTML is that tags are written inside of < and >, and a closing tag is denoted via a </ and >. Every opening tag must have a closing tag (save for a few self-closing tags), and the content of the tag is\n1\ncontained between the opening and closing tags. Notice above that <html> is closed by </html> at the bottom of the document, and likewise for <head>, <body>, <p>, and <a>.\n\nHere are some different types of tags:\n• <html> tags mark the start and end of the website. There can be only one html section.\n• <head> marks the beginning of the metadata section of a website. The head section normally contain tags that\nload page materials (fonts, scripts).\n• <script> tags contain JavaScript, or reference an external JavaScript ﬁle that should be loaded and ran.\n• <body> marks the main content of a website. This is where most visible text will be located.\n• <p> tags are used to denote different paragraphs.\n• <a> tags represent hyperlinks and will be a main focus of this project. The href parameter contains the des-\ntination of the link, and the text between the <a> tags contains the visible text. When a link does not cross domains (i.e. the part between the https:// and the .com/.org/…), it can start with a / to move between pages in the same domain easily. For example, when the source page is also on the https://wikipedia.org domain, the link https://wikipedia.org/wiki/Computer can be accessed either by the parameter href=”https://wikipedia.org/wiki/Computer” or the parameter href=”/wiki/Computer” . Since we are starting on Wikipedia and ending on Wikipedia, we only want to follow links in the form href=”/wiki/*”, since that will ensure that we stay on the https://wikipedia.org domain.\n\nYour ﬁrst task is to implement the get_links_in_page function inside of py_wikiracer/wikiracer.py.\nThis function accepts the HTML code for a single webpage and should ﬁnd all of the valid links inside of that page. For instance, running the function with the example HTML code above should return [“/wiki/Computer”]. Be sure to return links in the order that they appear, and be sure to ﬁlter out duplicate entries.\n\nAdditionally, there are a few characters that will invalidate a link in our game. These characters are the colon, pound sign, forward slash, and question mark. You should not hardcode these four characters into being disallowed, but rather use the DISALLOWED global variable provided inside py_wikiracer/wikiracer.py. If a link is found with one of these characters, you can pretend it doesn’t exist in the HTML. Also, if a link is found that doesn’t start with /wiki/, then you can pretend it doesn’t exist, since it could be an external link that takes us outside of Wikipedia.\n\nIf you want to play around with HTML, you can save the example script above in an .html ﬁle, and then open it with a web browser. You can (and should) look around real websites’ HTML by using the Inspect Element feature avaliable on most web browsers. In Google Chrome, F12 opens the Inspect Element menu, where you can click on a speciﬁc piece of text within a website to look at the underlying HTML code. Before starting the project, we encourage you to look at different websites’ HTML structure, and see how the links look on Wikipedia. You can also save a ﬁle with Ctrl-S to download its HTML markup and examine it with a text editor.\n\nTo accomplish your task, you should make good use of Python’s built in string functions to search for identiﬁable\nlandmarks near links. You can use Regex to ﬁnd links as well (though be wary of speed).\n\n2.2 Shortest Path Routines\nThe second part of the assignment is to implement 3 different search routines to create a naive wikiracer. We use Wikipedia as our graph, with websites representing vertices and links representing edges, and we want to efﬁciently tra-\nverse Wikipedia to ﬁnd the shortest path",
      "price": "$24.99",
      "category": "DSC395T",
      "tags": ["2025", "395t", "algorithms", "data", "disc", "dsc-395t", "software", "solved", "spring", "structures", "wikiracer"]
    },
    {
      "id": 2,
      "title": "DSC 395T Algorithms and Data Structures — Spring 2025 B-Trees Solved",
      "description": "In this assignment, you will implement a B-Tree data structure, which will give you experience in creating your own specialized data structure as well as the challenge of ﬁnding and ﬁxing code bugs.\n\n1 B-Trees\nRecall from lecture that B-Trees are an important data structure that are used to store large (and at times distributed) dictionaries, such as ﬁlesystems and databases. Thus, B-Trees support the three Dictionary operations:\n• find(key) -> value: Retrieve the value associated with the given key, if one exists.\n• insert(key, value): Insert the given key into the dictionary and associate with it the given value.\n• delete(key): Delete the given key and its associated value.\n\nTo minimize disk accesses, B-Trees are short and wide m-ary trees, where m is an integer ≥ 2 that is chosen to ﬁt as many keys and pointers into a node as possible, where the size of each node is deﬁned by the size of a disk block. Similarly, the constant l is chosen to pack as many data items as possible into a disk block.\n\nRecall the deﬁnition of a B-Tree:\n• Each node has at most m children\n• Each non-leaf and non-root node has at least (cid:6) m\n2\n(cid:7) children\n• A non-leaf node with k children contains k − 1 comparable keys\n• The root, if it isn’t a leaf, has at least 2 children\n• Each leaf node holds between (cid:6) l\n(cid:7) and l data items\n2\n• If the leaf is the root, it can have a minimum of zero data items\n• All leaves reside at the same level\n\n2 Your Assignment\nBuilding on the starter code in tree.py, create a working implementation of a B-Tree dictionary that supports the find and insert methods. To simplify your task, we are not asking you to implement the delete method. We also are not allowing duplicate keys in the B-Tree; inserts with the same key should overwrite old values.\n\nThe main, overarching goal of this assignment is to be able to grasp the concept of disk vs. memory. You will not be able to store the nodes of your B-Tree in memory, as your natural instincts would lead you to do. Instead, the point of a B-Tree is to have each node reside in its own disk block, which means that the nodes can only keep their structure by storing the disk block addresses of other nodes. For example, a node could be stored in disk block 1, whereas its children are stored in blocks 2, 3, and 4. The node’s data would consist of two keys (in your assignment, of type KT) as well as a list of addresses of its three children: [2, 3, 4]. The only data that you will be allowed to store in memory is the B-Tree object itself, which provides an interface for the dictionary operations. However, this object can only store three things: the value of m, the value of l, , and the disk address of its root node. All other information about the tree must be stored on disk.\n\n2.1\nInteracting with the Disk\nTo avoid making you go through the cumbersome process of obtaining and writing to disk blocks, we have abstracted away the disk interface through the disk.py module. You should not touch any of the code in this ﬁle, and all you will need from it is from disk import DISK, which has already been added for you. This DISK variable is a singleton disk instance, which provides the following methods:\n1\n• DISK.new() -> address: Allocates a new disk block and returns its address. Use this to create an address\nfor a new node.\n• DISK.write(address, BTreeNode): Writes the given BTreeNode to the disk at the given address.\n• DISK.read(address) -> BTreeNode: Returns the node that you last wrote to that address.\n\n2.2 Correctness\nBe sure that your B-Tree implementation meets the following requirements:\n• Many items can be inserted in a variety of orderings and with a variety of m-values and l-values without causing\nan error.\n• Each item that is inserted can be subsequently found using find.\n• Your B-Tree’s data can be entirely recovered from everything that is written to disk, as well as the m-value, the\nl-value, and the address of the root.\n• Your B-Tree should store keys in ascending order, so that it is possible to lookup a child address in logarithmic\ntime using binary search.\n\nYou should again extend upon the given test cases in tests/test_btrees.py. Since there is no GUI, you will need to rely on writing test cases to convince yourself that your code works as expected. Run the test suite with poetry run pytest -v. To run your code in the interactive Python interpreter, run poetry run python3 outside of the tests and py_btrees folders, and import your BTree code with >>> from py_btrees.btree import BTree.\n\n3 Karma\nOne obvious way to challenge",
      "price": "$24.99",
      "category": "DSC395T",
      "tags": ["2025", "395t", "algorithms", "data", "disc", "dsc-395t", "software", "solved", "spring", "structures", "wikiracer"]
    },
    {
      "id": 3,
      "title": "Assignment 3: Algorithms",
      "description": "Study sorting and searching algorithms.",
      "price": "$20"
    }
]